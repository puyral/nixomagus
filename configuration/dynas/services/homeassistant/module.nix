{
  lib,
  pkgs,
  config,
  ...
}:
with lib;
let
  cfg = config.my.homeassistant;
  ha_name = cfg.serviceName;
  ha_net = cfg.innerNetworkServiceName;
  # format = pkgs.formats.yaml { };
  # configFile = format.generate "zigbee2mqtt.yaml" cfg.settings;
  mkDocker =
    name: attrs:
    let
      is_tranparent = builtins.hasAttr "port" attrs;
      toMerge = {
        labels =
          if is_tranparent then
            {
              "traefik.enable" = "true";
              "traefik.http.routers.${name}.entrypoints" = "https";
              "traefik.http.routers.${name}.rule" = "Host(`${name}.puyral.fr`)";
              "traefik.http.routers.${name}.tls.certresolver" = "ovh";
              "traefik.http.services.${name}.loadbalancer.server.port" = builtins.toString attrs.port;
            }
          else
            { };
        autoStart = true;
        extraOptions = [
          "--network-alias=${name}"
          "--network=${cfg.innerNetwork}"
        ] ++ (if is_tranparent then [ "--network=traefik" ] else [ ]) ++ (attrs.extraOptions or [ ]);
        environment = {
          TZ = config.time.timeZone;
        };
      };
      # nattrs = if is_tranparent then builtins.removeAttrs "port" attrs else attrs;
      nattrs = attrsets.filterAttrs (
        n: v:
        !(elem n [
          "port"
          "extraOptions"
        ])
      ) attrs;
    in
    (attrsets.recursiveUpdate nattrs toMerge);
  mkService = name: attrs: {
    name = "docker-${name}";
    value = {
      # serviceConfig = {
      #   Restart = lib.mkOverride 500 "always";
      #   RestartMaxDelaySec = lib.mkOverride 500 "1m";
      #   RestartSec = lib.mkOverride 500 "100ms";
      #   RestartSteps = lib.mkOverride 500 9;
      # };
      after = [
        "${ha_net}.service"
        "traefik-docker-network.service"
      ];
      requires = [
        "${ha_net}.service"
        "traefik-docker-network.service"
      ];
      partOf = [ "${ha_name}.target" ];
      wantedBy = [ "${ha_name}.target" ];
    };
  };

in
{
  options.my.homeassistant = {
    serviceName = mkOption {
      type = types.str;
      default = "ha-root";
    };
    ha = {
      port = lib.mkOption { default = 8123; };
    };
    innerNetwork = mkOption {
      default = "${ha_name}-net";
      description = "the inner network name";
      type = types.str;
    };
    innerNetworkServiceName = mkOption { default = "${ha_name}-net"; };

    containers = mkOption { type = types.attrs; };
  };

  config = {
    virtualisation.oci-containers.containers = attrsets.mapAttrs mkDocker cfg.containers;
    systemd.services = (attrsets.mapAttrs' mkService cfg.containers) // {
      "${cfg.innerNetworkServiceName}" = {
        path = [ pkgs.docker ];
        serviceConfig = {
          Type = "oneshot";
          RemainAfterExit = true;
          ExecStop = "docker network rm -f ${cfg.innerNetwork}";
        };
        script = ''
          docker network inspect ${cfg.innerNetwork} || docker network create ${cfg.innerNetwork}
        '';
        partOf = [ "${ha_name}.target" ];
        wantedBy = [ "${ha_name}.target" ];
      };
    };
    systemd.targets."${ha_name}" = {
      unitConfig = {
        Description = "Root target generated by compose2nix.";
      };
      wantedBy = [ "multi-user.target" ];
    };
  };
}
